## Введение

### Условие задачи

В текстовом файле содержатся целые числа. Построить ДДП из чисел файла. Вывести его на экран в виде дерева. Сбалансировать полученное дерево и вывести его на экран. Построить хеш-таблицу из чисел файла. Использовать закрытое хеширование для устранения коллизий. Осуществить удаление введенного целого числа в ДДП, в сбалансированном дерево, в хеш-таблице и в файле. Сравнить время удаления, объем памяти и количество сравнений при использовании различных (4-х) структур данных. Если количество сравнений в хеш-таблице больше указанного, то произвести реструктуризацию таблицы, выбрав другую функцию.

## Техническое задание

В текстовом файле содержатся целые числа. Построить ДДП из чисел файла. Вывести его на экран в виде дерева. Сбалансировать полученное дерево и вывести его на экран. Построить хеш-таблицу из чисел файла. Использовать закрытое хеширование для устранения коллизий. Осуществить удаление введенного целого числа в ДДП, в сбалансированном дерево, в хеш-таблице и в файле. Сравнить время удаления, объем памяти и количество сравнений при использовании различных (4-х) структур данных. Если количество сравнений в хеш-таблице больше указанного, то произвести реструктуризацию таблицы, выбрав другую функцию.

### Входные данные

* Номер команды из меню
* Имя файла
* Номер команды из дополнительного меню

### Выходные данные

В зависимости от выбранного действия выходными данными могут являться:

* Построенное ДДП
* Построенное сбалансированное дерево
* Хеш-таблица
* Анализ эффективности удаления

## Способ обращения к программе

./app.exe

Выбор одного пункта меню:

* 0 - выход
* 1 - Построить ДДП
  * 0 - выход
  * 1 - Удалить вершину в ДДП
* 2 - Построить сбалансированное дерево
  * 0 - выход
  * 1 - Удалить вершину в ДДП
* 3 - Построить хеш-таблицу
  * 0 - выход
  * 1 - Удалить указанное число из хеш-таблицы
* 4 - Анализ эффективности удаления из разных структур данных

## Описание внутренних структур данных

```c
//Узел дерева
typedef struct node tree_node_t;

struct node
{
    int data;           // Число, содержадееся в узле
    tree_node_t *left;  // Ссылка на левый нижний узел
    tree_node_t *right; // Ссылка на правый нижний узел
};
```
```c
// 1 запись в хеш-таблице
typedef struct
{
    int data;       // Данные
    int is_free;    // Свобободна ли ячейка хеш-таблицы
    int is_deleted; // Были ли удалены данные из ячейки
} data_record_t;
```

```c
// Хеш-таблица
typedef struct
{
    data_record_t *arr; // Массив записей
    int table_size;     // Максимальный размер таблицы
    int cur_size;       // Текущий размер таблицы
} hash_table_t;
```

## Основные функции

### Функции для работы с ДДП

```c
// Инициализация дерева
tree_node_t *init_tree(FILE *f);
// Освобождение дерева
void tree_free(tree_node_t *tree);
// Поиск элемента в дерево
tree_node_t *find(tree_node_t *head, long elem);
// Вставка элемента в дерево
tree_node_t *insert(tree_node_t *head, tree_node_t *elem);
//Удаление элемента из дерева
tree_node_t *del(tree_node_t *head, long elem);
```

### Функции для работы с АВЛ-деревом

```c
//Инициализачия АВЛ-дерева
tree_node_t *init_balance_tree(FILE *f);
// Вставка в АВЛ-дерево
tree_node_t *insert_in_avl(tree_node_t *head, tree_node_t *elem);
//Балансировка АВЛ-дерева
tree_node_t *balance(tree_node_t *node);
int cmp_balance(tree_node_t *node);
tree_node_t *rotate_left(tree_node_t *node);
tree_node_t *rotate_right(tree_node_t *node);
size_t get_height(tree_node_t *head);
//Удаление из АВЛ-дерева
tree_node_t *del_in_avl(tree_node_t *head, long elem);
```

### Функции для работы с хеш-таблицей

```c
// хеш-функции
int hash6432shift(long long key, int size);
int Hash_UInt_M3(long long key, int size);
int hash32shiftmult(int key, int size);

// функции хеш-таблицы
int hash(int key, int table_size);
void insert_in_hash_table(hash_table_t *hash_t, int data, int *num_of_collision, int *temp_cmp);
int find_in_hash_table(hash_table_t *hash_t, int data, int *temp_cmp);
int delete_in_hash_table(hash_table_t *hash_t, int data, int *num_cmp);
int change_hash_function(hash_table_t *hash_t); // реструктурирование
int create_hash_table(hash_table_t *hash_t, int size, FILE *f, int *num_of_collisions, int *temp_cmp, int max_colls);
```

### Функции для работы с файлом

```c
// Поиск элемента
int find_in_file(char name[STR_MAX], int data, int *temp_cmp);
// Удаление элемента
void delete_in_file(char name[STR_MAX], int data, int *temp_cmp, uint64_t *time);
```

## Описание алгоритма

При закрытом (внутреннем) хешировании в хеш-таблице хранятся непосредственно сами элементы, а не заголовки списков элементов. Поэтому в каждой записи (сегменте) может храниться только один элемент. При закрытом хешировании применяется методика повторного хеширования. Если осуществляется попытка поместить элемент х в сегмент с номером h(х), который уже занят другим элементом (коллизия), то в соответствии с методикой повторного хеширования выбирается последовательность других номеров сегментов h1(х),h2(х),..., куда можно поместить элемент х. Каждое из этих местоположений последовательно проверяется, пока не будет найдено свободное. Если свободных сегментов нет, то, следовательно, таблица заполнена, и ее надо увеличить и переписать все записи с использованием новой хеш-функции (реструктурировать).

## Тесты

| Входные данные                          | Результат              |
| --------------------------------------- | ---------------------- |
| Выбор 1 пункта меню </br> data/test.txt | ![s](graph_test.png)   |
| Выбор 2 пункта меню </br> data/test.txt | ![s](Screenshot_2.png) |
| Выбор 3 пункта меню </br> data/test.txt | ![s](Screenshot_3.png) |

## Оценка эффективности удаления

![s](Screenshot_6.png)
![s](Screenshot_1.png)

## Вывод

Использование хеш-таблицы для удаления записи при небольшом их количестве уступает в эффективности по времени удалению из ДДП. Однако, чем больше записей требуется хранить, тем эффективнее хеш-таблица. По памяти же хеш-таблица практически всегда проигрывает. Это можно объяснить недостатками метода открытой адресации (закрытого хеширования).

В среднем хеш-таблица:

- занимает в ~14,5 раз больше памяти, чем ДДП
- занимает в ~24 раза больше памяти, чем сбалансированное дерево
- занимает в ~2 раза больше памяти, чем файл

Такая неэффективность по памяти хеш-таблицы, объясняется недостатками метода закрытого хеширования. Данный метод предполагает, что нам известем максимальный размер таблицы, поэтому, если число записей превышает этот размер, то новые записи невозможно вставлять без выделения бОльшего размера и повторного вычисления значений хеширования для ключей всех записей, находящихся уже в таблице, используя новую хеш-функцию (реструктуризация таблицы). Более того, из такой таблицы трудно удалять запись (ключ).

При этом в среднем удадение в хеш-таблице:

- на 10% быстрее удаления в ДДП
- в 202 раза быстрее удаления в сбалансированном дереве
- в 37826 раз быстрее удаления в файле

Стоит учитывать, что при небольшом количестве элементов (~ до 2000) удаление в ДДП в 2 раза быстрее, чем в хеш-таблице. Это объясняется тем, что необходимое значение находится достаточно близко к вершине. Однако если количество элементов >~2000, то удаление в хеш-таблице быстрее быстрее ~ в 2 раза. аким образом, можно сделать вывод, что при увеличении количества записей хеш-таблица будет гораздо эффективнее.

Удаление в хеш-таблице быстрее удаления в сбалансированном дереве, т.к. после удаления элемента дерево надо опять сбалансировать. Записи в файле при удалении надо переписывать полностью, поэтому удаление элемента в нем наименее выгодно.

## Контрольные вопросы

1. Что такое дерево?
   
   Дерево – это рекурсивная структура данных, используемая для представления иерархических связей имеющих отношение «один ко многим».
2. Как выделяется память под представление деревьев?
   
   В виде связного списка — динамически под каждый узел.
3. Какие стандартные операции возможны над деревьями?
   
   Обход дерева, поиск по дереву, включение в дерево, исключение из дерева.
4. Что такое дерево двоичного поиска?
   
   Двоичное дерево поиска - двоичное дерево, для каждого узла которого сохраняется условие: левый потомок больше или равен родителю, правый потомок строго меньше родителя (либо наооборот).
5. Чем отличается идеально сбалансированное дерево от АВЛ дерева?
   
   У АВЛ дерева для каждой его вершины высота двух её поддеревьев различается не более чем на 1, а у идеально сбалансированного дерева различается количество вершин в каждом поддереве не более чем на 1.
6. Чем отличается поиск в АВЛ-дереве от поиска в дереве двоичного поиска?
   
   Поиск в АВЛ дереве происходит быстрее, чем  в ДДП.
7. Что такое хеш-таблица, каков принцип ее построения?
   
   Хеш-таблицей называется массив, заполненный элементами в порядке, определяемом хеш-функцией. Хеш-функция каждому элементу таблицы ставит в соответствие некоторый индекс. Функция должна быть простой для вычисления,распределять ключи в таблице равномерно и давать минимум коллизий.
8. Что такое коллизии? Каковы методы их устранения.
   
   Коллизия – ситуация, когда разным ключам хеш-функция ставит в соответствие один и тот же индекс. Основные методы устранения коллизий: открытое и закрытое хеширование. При открытом хешировании к ячейке по данному ключу прибавляется связанны список, при закрытом – новый элемент кладется в ближайшую свободную ячейку после данной.
9.  В каком случае поиск в хеш-таблицах становится неэффективен?
    
    Поиск в хеш-таблице становится неэффективен при большом числе коллизий –сложность поиска возрастает по сравнению с О(1). В этом случае требуется реструктуризация таблицы – заполнение её с использованием новой хеш-функции.
10. Эффективность поиска в АВЛ деревьях, в дереве двоичного поиска и в хеш-таблицах.
    
    В хеш-таблице минимальное время поиска О(1). В АВЛ: О(log2n). В дереве двоичного поиска О(h), где h - высота дерева (от log2n до n).